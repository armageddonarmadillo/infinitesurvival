<html><body style='background-color:#141414; display: flex; justify-content:center'>
<canvas id='gameboard' style='border: 2px solid lime; overflow: hidden;'/>
<script>
	document.addEventListener('mousedown', input)
	document.addEventListener('mouseup', input)
	document.addEventListener('mousemove', follow)
	document.addEventListener('keydown', keyinput)
	document.addEventListener('keyup', keyinput)
	
	//canvas elements, borders, context, w/h
	const canvas = document.getElementById('gameboard')
	canvas.width = document.body.clientWidth
	canvas.height = document.body.clientHeight
	var c = canvas.getContext('2d')
	
	console.log(canvas.width + ', ' + canvas.height)
	
	//unit vars to be init
	var started, delay, tick, score, enemies
	
	//game elements
	var w, a, s, d
	var ttl = 'infinite survival' //title
	var ins = 'CLICK TO BEGIN' //instructions
	var player = [0, 0, 32]
	var clicked = false
	var xspeed = 0, yspeed = 0, angle = 0, playerspeed = 1
	var targetloc = []
	var inputs = []
	/*
		- player structure to change soon, should be composed of assorted portions
		- size should be standardized and scaling should be added to screen size
		- body should be an arc
		- limbs should be smaller arcs
		- weapons/upgrades attached to smaller arcs depending on gameplay
		- logic should be written to accept any variable size of player + limb combinations
		
		concept structure:
		
		player = [x, y, r] location and radius of arc
		player = [[x,y,r], [x,y,r], [x,y,r], [x,y,r], [x,y,r]] index 0 for location and radius of main player arc, 1, 2, 3, 4 for limbs (depending on how many are needed)
		
	*/
	
	draw()
	
	function init() {
		started = true
		delay = 999
		tick = 0
		score = 0
		enemies = []
		//center player on screen
		player = [canvas.width / 2 - player[2] / 2, canvas.height / 2 - player[2] / 2, player[2]]
	}
	
	function input(e) {
		//when mouse is clicked update player travel angle
		clicked = started && e.type == 'mousedown'
		started ? clicked&&updateplayerangle(e.x, e.y) : init()
	}
	
	function follow(e) {
		//continue to update player travel angle while mouse is held down
		started&&clicked&&updateplayerangle(e.x, e.y)
	}
	
	function keyinput(e) {
		//check for keydown, add most recent key to inputs
		e.type == 'keydown'&&(inputs = inputs.indexOf(e.code) == -1 ? [...inputs, e.code] : inputs)
		//check for keyup, remove most recent key from inputs
		e.type == 'keyup'&&(inputs = inputs.filter((v) => { return v != e.code }))
	}
	
	function checkkeys(){
		//check if there are no key inputs and check if there are no mouse inputs to escape and stop function
		if(inputs.length == 0) { if(targetloc.length == 0) { xspeed = 0; yspeed = 0; } return }
		//reset targetloc to prevent mouse from interupting keyboard unintentionally
		targetloc = []
		var v = false, h = false, xDir = 0, yDir = 0
		for(var i = inputs.length; i >= 0; i--){
			v = inputs[i] == 'KeyW' && !v ? (yDir = -1, true) : inputs[i] == 'KeyS' && !v ? (yDir = 1, true) : v
			h = inputs[i] == 'KeyA' && !h ? (xDir = -1, true) : inputs[i] == 'KeyD' && !h ? (xDir = 1, true) : h
		}
		xspeed = xDir * playerspeed
		yspeed = yDir * playerspeed
	}
	
	function checkmouse(){
		//move player to mouse target, if it reaches mouse target stop moving
		if(Math.round(player[0]) == targetloc[0] && Math.round(player[1]) == targetloc[1]) { targetloc = []; return }
	}
	
	function updateplayerangle(x, y){
		//check if a click exists and update targetloc to click location
		clicked&&(targetloc[0] = x, targetloc[1] = y)
		//update angle to travel to targetloc
		angle = Math.atan((player[1] - y)/(player[0] - x)) + (player[0] >= x ? Math.PI : 0)
		//update player speeds
		xspeed = Math.cos(angle) * playerspeed
		yspeed = Math.sin(angle) * playerspeed
	}
	
	function updateplayer(){
		player[0] += xspeed
		player[1] += yspeed
	}
	
	function addenemy(){
		console.log('enemy added')
		//enemies need to randomly spawn just outside the screen
		//enemies consist of location (x, y), arc radius, angle, xspeed, yspeed
		enemies = [...enemies, [
								parseInt(Math.random() * canvas.width),
								parseInt(Math.random() * canvas.height),
								28, //parseInt(Math.random() * 50) + 100 add random widths? or maybe presets for different types of enemies
								0,
								0.2,
								0.2
								]]
	}
	
	function updateenemies(){
		for(var i = 0; i < enemies.length; i++){
			//enemies will move at an angle towards player, some may have differing behaviour so likely different lists to interate thru
			enemies[i][3] = Math.atan((enemies[i][1] - player[1])/(enemies[i][0] - player[0])) + (enemies[i][0] >= player[0] ? Math.PI : 0)
			enemies[i][0] += Math.cos(enemies[i][3]) * enemies[i][4]
			enemies[i][1] += Math.sin(enemies[i][3]) * enemies[i][5]
		}
	}
	
	function update() {
		//tickable updates
		tick++>=delay&&(tick = 0, addenemy())
		
		//updates
		checkmouse()
		checkkeys()
		updateplayer()
		updateenemies()
	}
	
	function draw() { started ? drawgame() : drawtitle() }
	
	function drawgame(){
		update()
		//if(tick++ >= delay){
			// reset tick
			//tick = 0
			
			//draw background fill
			c.beginPath()
			c.fillStyle = '#101010'
			c.fillRect(0, 0, canvas.width, canvas.height)
			
			//draw player
			c.beginPath()
			c.fillStyle = '#ffbaba'
			c.arc(player[0], player[1], player[2], 0, 2 * Math.PI)
			c.fill()
			c.stroke()

			//draw enemies
			enemies.forEach((e) => {
				c.beginPath()
				c.fillStyle = '#ff3333'
				c.arc(e[0], e[1], e[2], 0, 2 * Math.PI)
				c.fill()
				c.stroke()
			})

			//draw targetloc
			if(targetloc.length > 0){
				c.beginPath()
				c.fillStyle = '#ffd300'
				c.moveTo(targetloc[0], targetloc[1])
				c.lineTo(targetloc[0] - 15, targetloc[1] - 50)
				c.lineTo(targetloc[0], targetloc[1] - 45)
				c.lineTo(targetloc[0] + 15, targetloc[1] - 50)
				c.lineTo(targetloc[0], targetloc[1])
				c.lineWidth = 3
				c.fill()
				c.stroke()
				c.closePath()
			}
		//}
		requestAnimationFrame(draw)
	}
	
	function drawtitle(){
		//fill background
		c.fillStyle = '#ead080'
		c.fillRect(0, 0, canvas.width, canvas.height)
		
		//draw titles
		c.fillStyle = '#006600'
		c.font = '64px monospace'
		c.fillText(	ttl, 
					canvas.width / 2 - c.measureText(ttl).width / 2, 
					canvas.height / 2 - 70
					)
					
		//draw instructions
		c.fillStyle = 'red'
		c.font = '42px monospace' 
		c.fillText(	ins, 
					canvas.width / 2 - c.measureText(ins).width / 2, 
					canvas.height / 2
					)
		requestAnimationFrame(draw)
	}
</script>