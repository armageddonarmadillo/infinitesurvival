<html><body style='background-color:#141414; display: flex; justify-content:center'>
<canvas id='gameboard' style='z-index: 2; width: 100%; height: 100%; overflow: hidden;' width= '1920' height='1080'/>
<script>
	document.addEventListener('mousedown', input)
	document.addEventListener('mouseup', input)
	document.addEventListener('mousemove', follow)
	document.addEventListener('keydown', keyinput)
	document.addEventListener('keyup', keyinput)
	
	//canvas elements, borders, context, w/h
	const canvas = document.getElementById('gameboard')
	var c = canvas.getContext('2d')
	
	//unit vars to be init
	var started, delay, tick, score, enemies, elimit
	
	//game elements
	var w, a, s, d
	var ttl = 'infinite survival' //title
	var ins = 'CLICK TO BEGIN' //instructions
	var player = [0, 0, 32]
	var clicked = false
	var xspeed = 0, yspeed = 0, angle = 0, playerspeed = 1.25
	var targetloc = []
	var inputs = []
	/*
		- player structure to change soon, should be composed of assorted portions
		- size should be standardized and scaling should be added to screen size
		- body should be an arc
		- limbs should be smaller arcs
		- weapons/upgrades attached to smaller arcs depending on gameplay
		- logic should be written to accept any variable size of player + limb combinations
		
		concept structure:
		
		player = [x, y, r] location and radius of arc
		player = [[x,y,r], [x,y,r], [x,y,r], [x,y,r], [x,y,r]] index 0 for location and radius of main player arc, 1, 2, 3, 4 for limbs (depending on how many are needed)
		
	*/
	
	draw()
	
	function init() {
		started = true
		delay = 50
		tick = 0
		score = 0
		enemies = []
		elimit = 100
		//center player on screen
		player = [canvas.width / 2 - player[2] / 2, canvas.height / 2 - player[2] / 2, player[2]]
	}
	
	function input(e) {
		//when mouse is clicked update player travel angle
		clicked = started && e.type == 'mousedown'
		started ? clicked&&updateplayerangle(e.x * (canvas.width / canvas.clientWidth), e.y * (canvas.height / canvas.clientHeight)) : init()
	}
	
	function follow(e) {
		//continue to update player travel angle while mouse is held down
		started&&clicked&&updateplayerangle(e.x * (canvas.width / canvas.clientWidth), e.y * (canvas.height / canvas.clientHeight))
	}
	
	function keyinput(e) {
		//check for keydown, add most recent key to inputs
		e.type == 'keydown'&&(inputs = inputs.indexOf(e.code) == -1 ? [...inputs, e.code] : inputs)
		//check for keyup, remove most recent key from inputs
		e.type == 'keyup'&&(inputs = inputs.filter((v) => { return v != e.code }))
	}
	
	function checkkeys(){
		//check if there are no key inputs and check if there are no mouse inputs to escape and stop function
		if(inputs.length == 0) { if(targetloc.length == 0) { xspeed = 0; yspeed = 0; } return }
		//reset targetloc to prevent mouse from interupting keyboard unintentionally
		targetloc = []
		var v = false, h = false, xDir = 0, yDir = 0
		for(var i = inputs.length; i >= 0; i--){
			v = inputs[i] == 'KeyW' && !v ? (yDir = -1, true) : inputs[i] == 'KeyS' && !v ? (yDir = 1, true) : v
			h = inputs[i] == 'KeyA' && !h ? (xDir = -1, true) : inputs[i] == 'KeyD' && !h ? (xDir = 1, true) : h
		}
		xspeed = xDir * playerspeed
		yspeed = yDir * playerspeed
	}
	
	function checkmouse(){
		//move player to mouse target, if it reaches mouse target stop moving
		if(parseInt(player[0]) == parseInt(targetloc[0]) && parseInt(player[1]) == parseInt(targetloc[1])) { targetloc = []; return }
	}
	
	function updateplayerangle(x, y){
		//check if a click exists and update targetloc to click location
		clicked&&(targetloc[0] = x, targetloc[1] = y)
		//update angle to travel to targetloc
		angle = Math.atan((player[1] - y)/(player[0] - x)) + (player[0] >= x ? Math.PI : 0)
		//update player speeds
		xspeed = Math.cos(angle) * playerspeed
		yspeed = Math.sin(angle) * playerspeed
	}
	
	function updateplayer(){
		//enemies = enemies.filter((e) => {
		//	return !collisioncheck(e, player)
		//})

		player[0] += xspeed
		player[1] += yspeed
	}
	
	function addenemy(){
		//enemies need to randomly spawn just outside the screen
		//enemies consist of location (x, y), arc radius, angle, xspeed, yspeed
		var randomSpawn = parseInt(Math.random()* 100) %2 == 0
		enemies =  [...enemies, [
								randomSpawn ? parseInt(Math.random()* 100) %2 == 0 ? -50 : canvas.width + 50 : parseInt(Math.random() * canvas.width), //Spawning enemy on the X-asis
								randomSpawn ? parseInt(Math.random() * canvas.height) : parseInt(Math.random()* 100) %2 == 0 ? -50 : canvas.height + 50, //Spawning enemy on the Y-asis
								Math.random() * 28 + 5, //parseInt(Math.random() * 50) + 100 add random widths? or maybe presets for different types of enemies //Radius
								0, //Angle
								Math.random() + 0.1,	//xSpeed
								Math.random() + 0.1,	//ySpeed
								'#' + Math.floor(Math.random()*16777215).toString(16) //color
								]]
	}

	
	
	function updateenemies(){
		enemies.forEach((e) => {
			e[3] = Math.atan((e[1] - player[1])/(e[0] - player[0])) + (e[0] >= player[0] ? Math.PI : 0)
			e[0] += Math.cos(e[3]) * e[4]
			e[1] += Math.sin(e[3]) * e[5]
			enemies.forEach((c) => {
				if(e != c) {
					if(collisioncheck(e, c)){
						const dx = e[0] - c[0], dy = e[1] - c[1], d = Math.hypot(dx, dy); //distance between enemies
						const m = (d - e[2] - c[2]) / (2 * d);	//movement calc
						e[0] -= m * dx, e[1] -= m * dy, c[0] += m * dx, c[1] += m * dy; //apply movement
					}
				}
			})
			
		})
	}

	function collisioncheck(a, b){
		// Calculate the distance between the centers of the circles
		var dx = a[0] - b[0];
  		var dy = a[1] - b[1];
  		var distance = Math.sqrt(dx * dx + dy * dy);

 		 // Check if the distance is less than the sum of the radii
  		if (distance < a[2] + b[2]) { return true ;}
		
  		// Circles are not colliding
  		return false;
	}
	
	function update() {
		//tickable updates
		tick++>=delay&&(tick = 0, enemies.length < elimit && addenemy())
		
		//updates
		checkmouse()
		checkkeys()
		updateplayer()
		updateenemies()
	}
	
	function draw() { started ? drawgame() : drawtitle() }
	
	function drawgame(){
		update()
		//if(tick++ >= delay){
			// reset tick
			//tick = 0
			
			//draw background fill
			c.beginPath()
			c.fillStyle = '#101010'
			c.fillRect(0, 0, canvas.width, canvas.height)
			
			//draw player
			c.beginPath()
			c.fillStyle = '#ffbaba'			
			c.arc(player[0], player[1], player[2], 0, 2 * Math.PI)
			c.fill()
			c.stroke()

			//draw enemies
			enemies.forEach((e) => {
				c.beginPath()
				c.fillStyle = e[6]
				c.arc(e[0], e[1], e[2], 0, 2 * Math.PI)
				c.fill()
				c.stroke()
			})

			//draw targetloc
			if(targetloc.length > 0){
				c.beginPath()
				c.fillStyle = '#ffd300'
				c.moveTo(targetloc[0], targetloc[1])
				c.lineTo(targetloc[0] - 15, targetloc[1] - 50)
				c.lineTo(targetloc[0], targetloc[1] - 45)
				c.lineTo(targetloc[0] + 15, targetloc[1] - 50)
				c.lineTo(targetloc[0], targetloc[1])
				c.lineWidth = 3
				c.fill()
				c.stroke()
				c.closePath()
			}
		//}
		requestAnimationFrame(draw)
	}
	
	function drawtitle(){
		//fill background
		c.fillStyle = '#ead080'
		c.fillRect(0, 0, canvas.width, canvas.height)
		
		//draw titles
		c.fillStyle = '#006600'
		c.font = '64px monospace'
		c.fillText(	ttl, 
					canvas.width / 2 - c.measureText(ttl).width / 2, 
					canvas.height / 2 - 70
					)
					
		//draw instructions
		c.fillStyle = 'red'
		c.font = '42px monospace' 
		c.fillText(	ins, 
					canvas.width / 2 - c.measureText(ins).width / 2, 
					canvas.height / 2
					)
		requestAnimationFrame(draw)
	}
	
</script>