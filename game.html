<html><body style='background-color:#141414; display: flex; justify-content:center'>
<canvas id='gameboard' style='border: 2px solid lime; overflow: hidden;'/>
<script>
	document.addEventListener('mousedown', input)
	document.addEventListener('mouseup', input)
	document.addEventListener('mousemove', follow)
	document.addEventListener('keydown', keyinput)
	document.addEventListener('keyup', keyinput)
	
	//canvas elements, borders, context, w/h
	const canvas = document.getElementById('gameboard')
	canvas.width = document.body.clientWidth
	canvas.height = document.body.clientHeight
	var c = canvas.getContext('2d')
	
	//unit vars to be init
	var started, delay, tick, score, enemies
	
	//game elements
	var w, a, s, d
	var ttl = 'infinite survival' //title
	var ins = 'CLICK TO BEGIN' //instructions
	var player = [0, 0, 32]
	var clicked = false
	var xspeed = 0, yspeed = 0, angle = 0, playerspeed = 1
	var targetloc = []
	var inputs = []
	/*
		- player structure to change soon, should be composed of assorted portions
		- size should be standardized and scaling should be added to screen size
		- body should be an arc
		- limbs should be smaller arcs
		- weapons/upgrades attached to smaller arcs depending on gameplay
		- logic should be written to accept any variable size of player + limb combinations
		
		concept structure:
		
		player = [x, y, r] location and radius of arc
		player = [[x,y,r], [x,y,r], [x,y,r], [x,y,r], [x,y,r]] index 0 for location and radius of main player arc, 1, 2, 3, 4 for limbs (depending on how many are needed)
		
	*/
	
	draw()
	
	function init() {
		started = true
		delay = 22
		tick = 0
		score = 0
		enemies = []
		//center player on screen
		player = [canvas.width / 2 - player[2] / 2, canvas.height / 2 - player[2] / 2, player[2]]
	}
	
	function input(e) {
		clicked = started && e.type == 'mousedown'
		started ? updateangle(e.x, e.y) : init()
	}
	
	function follow(e) {
		started&&clicked&&updateangle(e.x, e.y)
	}
	
	function keyinput(e) {
		//started&&manualplayerupdate(e.code, e.type)
		//w = e.code == 'KeyW' && e.type == 'keydown'
		//s = e.code == 'KeyS' && e.type == 'keydown'
		//d = e.code == 'KeyD' && e.type == 'keydown'
		//a = e.code == 'KeyA' && e.type == 'keydown'

		/*if(e.type == 'keydown'){
			if(e.code == 'KeyW') w = true
			if(e.code == 'KeyS') s = true
			if(e.code == 'KeyA') a = true
			if(e.code == 'KeyD') d = true
			//console.log(e.code)
			//console.log(e.type)
		} else if(e.type == 'keyup'){
			if(e.code == 'KeyW') w = false
			if(e.code == 'KeyS') s = false
			if(e.code == 'KeyA') a = false
			if(e.code == 'KeyD') d = false
		}*/

		if(e.type == 'keydown'){
			inputs = inputs.indexOf(e.code) == -1 ? [...inputs, e.code] : inputs
		}
		else if(e.type == 'keyup'){
			inputs = inputs.filter((v) => {
				v != e.code
			})
		}
		console.log(inputs)
	}
	
	function manualplayerupdate(){
		//reset targetloc to nothing so it can't be followed by other controller logic
		targetloc = []
		//this works but feels weird needs to be cleaned up (switching directions with wasd feels awkward)
		//xspeed = type == 'keydown' ? code == 'KeyA' ? -1 : code == 'KeyD' ? 1 : xspeed : 0
		//yspeed = type == 'keydown' ? code == 'KeyW' ? -1 : code == 'KeyS' ? 1 : yspeed : 0
		//xspeed = a ? -1 : d ? 1 : 0
		//yspeed = w ? -1 : s ? 1 : 0		
		
		
		var v = false, h = false, xDir = 0, yDir = 0
		for(var i = inputs.length; i > 0; i--){
			if(v && h)
				break;

			switch(inputs[i]){
				case 'KeyW':
					v = true
					yDir = -1
					break;
				case 'KeyS':
					v = true
					yDir = 1
					break
				case 'KeyA':
					h = true
					xDir = -1
					break;
				case 'KeyD':
					h = true
					xDir = 1
					break
			}

		}
		xspeed = xDir * playerspeed
		yspeed = yDir * playerspeed	
			

		console.log(xspeed)


		/*
			Idea for a fix / strong solution:
			- like how mouse movements record targetlocation to allow the player to finish pathing after button is released
			- record states when a key is pressed/released and apply those speeds based on recorded values (boolean)
			- example being:
			w = f, a = f, s = f, d = f for no movements
			when w is pressed down set w = t
			player will now move up
			when s is pressed down set s = t
			player will now stand still because w is still pressed
			when w is released set w = f
			player will now move down because s is pressed but w was released
			adding a/d = f/t should allow for clear diagonal movements with manual control
		*/
	}
	
	function updateangle(x, y){
		if(clicked) { targetloc[0] = x; targetloc[1] = y }
		angle = Math.atan((player[1] - y)/(player[0] - x)) + (player[0] >= x ? Math.PI : 0)
		xspeed = Math.cos(angle) * playerspeed
		yspeed = Math.sin(angle) * playerspeed
	}
	
	function moveplayertotarget(){
		if(Math.round(player[0]) == targetloc[0] && Math.round(player[1]) == targetloc[1]) { return }
		player[0] += xspeed
		player[1] += yspeed
	}
	
	function update() {
		tick++
		
		moveplayertotarget()
		manualplayerupdate()
	}
	
	function draw() { started ? drawgame() : drawtitle() }
	
	function drawgame(){
		update()
		//if(tick++ >= delay){
			// reset tick & draw background fill
			tick = 0
			c.beginPath()
			c.fillStyle = '#101010'
			c.fillRect(0, 0, canvas.width, canvas.height)
			
			//draw player
			c.beginPath()
			c.fillStyle = '#ffbaba'
			c.arc(player[0], player[1], player[2], 0, 2 * Math.PI)
			c.fill()			
		//}
		requestAnimationFrame(draw)
	}
	
	function drawtitle(){
		c.fillStyle = '#ead080'
		c.fillRect(0, 0, canvas.width, canvas.height)
		c.fillStyle = '#006600'
		c.font = '64px monospace'
		c.fillText(	ttl, 
					canvas.width / 2 - c.measureText(ttl).width / 2, 
					canvas.height / 2 - 70
					)
		c.fillStyle = 'red'
		c.font = '42px monospace' 
		c.fillText(	ins, 
					canvas.width / 2 - c.measureText(ins).width / 2, 
					canvas.height / 2
					)
		requestAnimationFrame(draw)
	}
</script>